import Steve from '@shell/plugins/steve/steve-class.js';
import { steveClassJunkObject } from './utils/steve-mocks';

describe('class: Steve', () => {
  describe('given custom resource keys', () => {
    const customResource = steveClassJunkObject;

    it('should keep internal keys', () => {
      const steve = new Steve(customResource, {
        getters:     { schemaFor: () => ({ linkFor: jest.fn() }) },
        dispatch:    jest.fn(),
        rootGetters: { 'i18n/t': jest.fn() },
      });

      expect({ ...steve }).toStrictEqual(customResource);
    });

    describe('method: save', () => {
      it('should remove all the internal keys', async() => {
        const dispatch = jest.fn();
        const steve = new Steve(customResource, {
          getters:     { schemaFor: () => ({ linkFor: jest.fn() }) },
          dispatch,
          rootGetters: { 'i18n/t': jest.fn() },
        });

        const expectation = {
          type:     customResource.type,
          metadata: {
            resourceVersion:            'whatever',
            fields:                     'whatever',
            clusterName:                'whatever',
            deletionGracePeriodSeconds: 'whatever',
            generateName:               'whatever',
            ownerReferences:            'whatever',
          },
          spec: { versions: {} }
        };

        await steve.save();

        const opt = {
          data:    expectation,
          headers: {
            accept:         'application/json',
            'content-type': 'application/json',
          },
          method: 'post',
          url:    undefined,
        };

        // Data sent should have been cleaned
        expect(dispatch).toHaveBeenCalledWith('request', { opt, type: customResource.type });

        // Original workload model should remain unchanged
        expect({ ...steve }).toStrictEqual(customResource);
      });
    });

    describe('method: processSaveResponse', () => {
      it('should call parent processSaveResponse', () => {
        const mockDispatch = jest.fn();
        const mockRootGetters = { 'i18n/t': jest.fn().mockReturnValue('Resource created: test-id') };
        const steve = new Steve(customResource, {
          getters:     { schemaFor: () => ({ linkFor: jest.fn() }) },
          dispatch:    mockDispatch,
          rootGetters: mockRootGetters,
        });

        // Mock the parent processSaveResponse method
        const parentProcessSaveResponse = jest.spyOn(Object.getPrototypeOf(Object.getPrototypeOf(steve)), 'processSaveResponse');

        const response = { _status: 200 };

        steve.processSaveResponse(response);

        expect(parentProcessSaveResponse).toHaveBeenCalledWith(response);
      });

      describe('growl notifications', () => {
        describe('should show growl notification', () => {
          it.each([
            {
              name:     'for autogenerated names on 201 status',
              response: {
                _status:  201,
                metadata: { generateName: 'test-generated-' },
                id:       'default/test-generated-abc123'
              },
              expectedResource: 'CustomResourceDefinition',
              expectedId:       'test-generated-abc123'
            },
            {
              name:     'for autogenerated names without namespace',
              response: {
                _status:  201,
                metadata: { generateName: 'simple-' },
                id:       'simple-id'
              },
              expectedResource: 'CustomResourceDefinition',
              expectedId:       'simple-id'
            }
          ])('$name', ({ response, expectedResource, expectedId }) => {
            const mockDispatch = jest.fn();
            const mockT = jest.fn((key, params) => {
              if (key === 'generic.autogeneratedCreated.title') {
                return `${ params.resource } created`;
              }
              if (key === 'generic.autogeneratedCreated.message') {
                return `Resource ${ params.id } created successfully`;
              }

              return key;
            });
            const mockRootGetters = { 'i18n/t': mockT };
            const steve = new Steve(customResource, {
              getters:     { schemaFor: () => ({ linkFor: jest.fn() }) },
              dispatch:    mockDispatch,
              rootGetters: mockRootGetters,
            });

            // Mock typeDisplay to return the expected resource label
            Object.defineProperty(steve, 'typeDisplay', { get: jest.fn(() => expectedResource) });

            steve.processSaveResponse(response);

            expect(mockT).toHaveBeenCalledWith('generic.autogeneratedCreated.title', { resource: expectedResource });
            expect(mockT).toHaveBeenCalledWith('generic.autogeneratedCreated.message', { id: expectedId, resource: expectedResource });

            expect(mockDispatch).toHaveBeenCalledWith(
              'growl/success',
              {
                title:   `${ expectedResource } created`,
                message: `Resource ${ expectedId } created successfully`,
                timeout: 3000
              },
              { root: true }
            );
          });
        });

        describe('should not show growl notification', () => {
          it.each([
            {
              name:     'for non-201 status',
              response: {
                _status:  200,
                metadata: { generateName: 'test-generated-' },
                id:       'default/test-generated-abc123'
              }
            },
            {
              name:     'without generateName',
              response: {
                _status: 201,
                id:      'default/test-regular-name'
              }
            },
            {
              name:     'without id',
              response: {
                _status:  201,
                metadata: { generateName: 'test-generated-' }
              }
            }
          ])('$name', ({ response }) => {
            const mockDispatch = jest.fn();
            const mockT = jest.fn();
            const mockRootGetters = { 'i18n/t': mockT };
            const steve = new Steve(customResource, {
              getters:     { schemaFor: () => ({ linkFor: jest.fn() }) },
              dispatch:    mockDispatch,
              rootGetters: mockRootGetters,
            });

            steve.processSaveResponse(response);

            expect(mockDispatch).not.toHaveBeenCalledWith(
              'growl/success',
              expect.any(Object),
              { root: true }
            );
          });
        });
      });
    });
  });
});
