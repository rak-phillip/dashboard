name: Daily issue grooming

on:
  schedule:
    - cron: "0 9 * * *"
  workflow_dispatch:

permissions:
  contents: read
  issues: write
  models: read
  id-token: write

jobs:
  groom-issues:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: '22'

      - name: Install gh-models extension
        run: gh extension install https://github.com/github/gh-models
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Groom issues with GitHub Models (JS)
        uses: actions/github-script@v8
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const ghToken = process.env.GH_TOKEN;

            function buildPrompt(title, body) {
              return `
                You are an experienced engineering lead helping groom GitHub issues for a development team.

                ## Grooming Decision Model (4 primary + 1 secondary)

                An issue is **groomed** when ALL FOUR primary criteria are clearly present.
                The fifth criterion may be absent or only partially met without blocking grooming.

                ### PRIMARY CRITERIA â€” all four must be fully satisfied

                1. **Clear Problem Statement**
                  - Title clearly summarizes the issue
                  - Description explains what is broken or needed and why it matters
                  - Context provided about where in the product the issue occurs

                2. **Acceptance Criteria / Requirements**
                  - At least 1â€“3 concrete, testable acceptance criteria (checklist preferred)
                  - User-facing and verifiable; not implementation details
                  - For bugs: defines what "fixed" looks like
                  - For features: defines what "done" looks like

                3. **Technical Details**
                  - For bugs: error messages and/or stack traces; specific files or components identified
                  - For features: enough technical context for an engineer to scope the work
                  - Config/environment details where relevant

                4. **Reproducibility**
                   - **Bugs**: numbered steps to reproduce + expected vs. actual behavior; preconditions stated. This is REQUIRED.
                   - **Features**: a clear user story or flow describing the desired behavior is sufficient. Numbered repro steps are NOT required and must not be asked for.

                ### SECONDARY CRITERION â€” partial satisfaction is acceptable

                5. **Dependencies / Additional Information**
                  - Related issues or PRs referenced (even one link is sufficient)
                  - Root cause hypotheses, workarounds, impact/severity
                  - Absence of this criterion does NOT block grooming

                ## Decision Rules

                - \`"is_groomed": true\`  â†’ all four PRIMARY criteria clearly present (dependencies optional)
                - \`"is_groomed": false\` â†’ one or more PRIMARY criteria are missing or too vague
                - For feature requests, criterion 4 is satisfied by a clear user story or flow â€” do NOT ask for reproduction steps
                - Be decisive; do not fail an issue for missing or incomplete dependencies alone
                - Ask at most 2â€“3 targeted questions focused only on the specific missing primary criteria
                - Do NOT ask about dependencies unless all four primary criteria are already met

                ## Examples

                **Groomed**: Clear problem description + explicit AC checklist + stack trace + numbered repro steps â†’ true (even with no related issues linked)
                **Not Groomed**: Clear problem + repro steps + stack trace, but no acceptance criteria â†’ false
                **Not Groomed**: Acceptance criteria + good description, but "Steps to reproduce: TBD" and no error details â†’ false
                **Not Groomed**: Vague title, no AC, no repro â†’ false

                Now evaluate this GitHub issue:

                Title:
                ${title}

                Body:
                ${body}

                In "questions_markdown", ask only about the specific missing primary criteria â€” no more than 2â€“3 focused questions.
                In "analysis_markdown", briefly summarize which criteria are met and which are not.

                Respond ONLY with a valid JSON object with this exact structure (no extra text before or after it):
                {
                  "is_groomed": boolean,
                  "analysis_markdown": string,
                  "questions_markdown": string
                }
              `.trim();
            }

            function buildReviewPrompt(title, body, previousQuestions) {
              return `
                You are an experienced engineering lead reviewing a GitHub issue that was previously flagged as needing more information.

                ## What the bot previously asked

                ${previousQuestions}

                ## Current issue state

                Title:
                ${title}

                Body:
                ${body}

                ## Grooming Decision Model (4 primary + 1 secondary)

                An issue is **groomed** when ALL FOUR primary criteria are clearly present.
                The fifth criterion may be absent or only partially met without blocking grooming.

                ### PRIMARY CRITERIA â€” all four must be fully satisfied

                1. **Clear Problem Statement**
                  - Title clearly summarizes the issue
                  - Description explains what is broken or needed and why it matters
                  - Context provided about where in the product the issue occurs

                2. **Acceptance Criteria / Requirements**
                  - At least 1â€“3 concrete, testable acceptance criteria (checklist preferred)
                  - User-facing and verifiable; not implementation details
                  - For bugs: defines what "fixed" looks like
                  - For features: defines what "done" looks like

                3. **Technical Details**
                  - For bugs: error messages and/or stack traces; specific files or components identified
                  - For features: enough technical context for an engineer to scope the work
                  - Config/environment details where relevant

                4. **Reproducibility**
                  - **Bugs**: numbered steps to reproduce + expected vs. actual behavior; preconditions stated. This is REQUIRED.
                  - **Features**: a clear user story or flow describing the desired behavior is sufficient. Numbered repro steps are NOT required and must not be asked for.

                ### SECONDARY CRITERION â€” partial satisfaction is acceptable

                5. **Dependencies / Additional Information**
                  - Related issues or PRs referenced (even one link is sufficient)
                  - Root cause hypotheses, workarounds, impact/severity
                  - Absence of this criterion does NOT block grooming

                ## Decision Rules

                - Evaluate the CURRENT issue body â€” the reporter may have edited it since the first review
                - \`"is_groomed": true\`  â†’ all four PRIMARY criteria now clearly present
                - \`"is_groomed": false\` â†’ one or more PRIMARY criteria are still missing or too vague
                - For feature requests, criterion 4 is satisfied by a clear user story or flow â€” do NOT ask for reproduction steps
                - Do NOT repeat questions that have already been answered in the current body
                - In "analysis_markdown", briefly acknowledge what has improved and what is still missing
                - In "questions_markdown", ask only about the specific criteria still outstanding â€” no more than 2â€“3 questions
                - Do NOT ask about dependencies unless all four primary criteria are already met

                Respond ONLY with a valid JSON object with this exact structure (no extra text before or after it):
                {
                  "is_groomed": boolean,
                  "analysis_markdown": string,
                  "questions_markdown": string
                }
              `.trim();
            }

            async function runGhModels(prompt) {
              const cmd = 'gh';
              const args = [
                'models',
                'run',
                'openai/gpt-4.1',   // or whatever model ID is enabled for your repo
                prompt,
              ];

              const { exitCode, stdout, stderr } = await exec.getExecOutput(cmd, args, {
                env: { ...process.env, GH_TOKEN: ghToken },
              });

              if (stderr) {
                core.debug(`gh stderr: ${stderr}`);
              }
              if (exitCode !== 0) {
                throw new Error(`gh models run failed with exit code ${exitCode}`);
              }
              return stdout.trim();
            }

            const sinceISO = new Date(Date.now() - 24 * 60 * 60 * 1000).toISOString();
            core.info(`Fetching issues since ${sinceISO}`);

            const issuesResp = await github.rest.issues.listForRepo({
              owner,
              repo,
              state: 'open',
              since: sinceISO,
              per_page: 100,
            });

            const since = new Date(Date.now() - 24 * 60 * 60 * 1000);
            const issues = issuesResp.data.filter((issue) => {
              if (issue.pull_request) return false;
              // Only process newly created issues
              if (new Date(issue.created_at) < since) return false;
              // Skip if already labeled by a previous grooming run
              const labelNames = (issue.labels || []).map((l) => l.name);
              if (labelNames.includes('groomed') || labelNames.includes('needs-info')) return false;
              return true;
            });
            core.info(`Found ${issues.length} issues to groom`);

            for (const issue of issues) {
              const number = issue.number;
              const title = issue.title || '';
              const body = issue.body || '';

              core.info(`Processing issue #${number}: ${title}`);

              const prompt = buildPrompt(title, body);
              const stdout = await runGhModels(prompt);
              core.debug(`Model raw output: ${stdout}`);

              let result;
              try {
                result = JSON.parse(stdout);
              } catch (err) {
                core.warning(
                  `Failed to parse model output for issue #${number}: ${err.message}`,
                );
                continue;
              }

              const isGroomed = !!result.is_groomed;
              const analysis = result.analysis_markdown || '';
              const questions = result.questions_markdown || '';

              let commentBody;
              if (isGroomed) {
                commentBody = `### ðŸ¤– Issue grooming analysis\n\n${analysis}\n\n_This analysis was generated automatically based on the repository's grooming checklist._`;
              } else {
                commentBody = `### ðŸ¤– Issue grooming questions\n\n${questions}\n\n_This comment was generated automatically to help gather the information needed to groom this issue._`;
              }

              await github.rest.issues.createComment({
                owner,
                repo,
                issue_number: number,
                body: commentBody,
              });

              try {
                if (isGroomed) {
                  await github.rest.issues.addLabels({
                    owner,
                    repo,
                    issue_number: number,
                    labels: ['groomed'],
                  });
                } else {
                  await github.rest.issues.addLabels({
                    owner,
                    repo,
                    issue_number: number,
                    labels: ['needs-info'],
                  });
                }
              } catch (err) {
                core.warning(
                  `Failed to add labels on issue #${number}: ${err.message}`,
                );
              }
            }

            const processedByQueueA = new Set(issues.map((i) => i.number));

            // --- Queue B: re-evaluate needs-info issues updated since last run ---
            const needsInfoResp = await github.rest.issues.listForRepo({
              owner,
              repo,
              state: 'open',
              labels: 'needs-info',
              since: sinceISO,
              per_page: 100,
            });

            const needsInfoIssues = needsInfoResp.data.filter((issue) => !issue.pull_request);
            core.info(`Found ${needsInfoIssues.length} needs-info issues to re-evaluate`);

            for (const issue of needsInfoIssues) {
              const number = issue.number;
              const title = issue.title || '';
              const body = issue.body || '';

              if (processedByQueueA.has(number)) {
                core.info(`Issue #${number}: just processed in Queue A this run, skipping`);
                continue;
              }

              // Fetch comments to find the last bot comment
              const commentsResp = await github.rest.issues.listComments({
                owner,
                repo,
                issue_number: number,
                per_page: 100,
              });

              const botComments = commentsResp.data.filter(
                (c) => c.user?.login === 'github-actions[bot]'
              );
              const lastBotComment = botComments[botComments.length - 1];

              // Skip if no new activity since the bot last commented
              if (lastBotComment && new Date(issue.updated_at) <= new Date(lastBotComment.created_at)) {
                core.info(`Issue #${number}: no new activity since last bot comment, skipping`);
                continue;
              }

              core.info(`Re-evaluating issue #${number}: ${title}`);

              const previousQuestions = lastBotComment?.body || '(no previous bot comment found)';
              const prompt = buildReviewPrompt(title, body, previousQuestions);
              const stdout = await runGhModels(prompt);
              core.debug(`Model raw output for re-evaluation of #${number}: ${stdout}`);

              let result;
              try {
                result = JSON.parse(stdout);
              } catch (err) {
                core.warning(`Failed to parse model output for issue #${number}: ${err.message}`);
                continue;
              }

              const isGroomed = !!result.is_groomed;
              const analysis = result.analysis_markdown || '';
              const questions = result.questions_markdown || '';

              let commentBody;
              if (isGroomed) {
                commentBody = `### ðŸ¤– Issue grooming analysis\n\n${analysis}\n\n_This analysis was generated automatically based on the repository's grooming checklist._`;
              } else {
                commentBody = `### ðŸ¤– Issue grooming questions\n\n${questions}\n\n_This comment was generated automatically to help gather the information needed to groom this issue._`;
              }

              await github.rest.issues.createComment({
                owner,
                repo,
                issue_number: number,
                body: commentBody,
              });

              if (isGroomed) {
                try {
                  await github.rest.issues.removeLabel({
                    owner,
                    repo,
                    issue_number: number,
                    name: 'needs-info',
                  });
                } catch (err) {
                  core.warning(`Failed to remove needs-info label on issue #${number}: ${err.message}`);
                }
                try {
                  await github.rest.issues.addLabels({
                    owner,
                    repo,
                    issue_number: number,
                    labels: ['groomed'],
                  });
                } catch (err) {
                  core.warning(`Failed to add groomed label on issue #${number}: ${err.message}`);
                }
              }
              // If still not groomed, needs-info label already present â€” no label change needed
            }
