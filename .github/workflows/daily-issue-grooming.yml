name: Daily issue grooming

on:
  schedule:
    - cron: "0 9 * * *"
  workflow_dispatch:

permissions:
  contents: read
  issues: write
  models: read
  id-token: write

jobs:
  groom-issues:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: '22'

      - name: Install gh-models extension
        run: gh extension install https://github.com/github/gh-models
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Groom issues with GitHub Models (JS)
        uses: actions/github-script@v8
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const ghToken = process.env.GH_TOKEN;

            function buildPrompt(title, body) {
              return `
                You are an experienced engineering lead helping groom GitHub issues for a development team.

                ## "Groomed Enough" Definition
                An issue is **groomed enough for implementation** when ALL of the following are true:
                - The problem or request is clearly stated in 1â€“3 sentences
                - There is at least one concrete acceptance criterion or expected outcome
                - There is enough technical/contextual detail for a typical engineer to start work without another synchronous conversation
                - Any missing details are minor and can be filled during implementation/review

                The issue does NOT need to satisfy every checklist item. Use the checklist as guidance, not a strict gate.

                ## Decision Rules
                - If the issue clearly states the problem + expected outcome, AND includes either (a) repro/technical details OR (b) concrete acceptance criteria, default to "is_groomed": true
                - Only set "is_groomed": false when an engineer would be realistically blocked from starting work
                - Prefer analysis/suggestions over questions when info is "nice to have" not required
                - Be ~80% lenient: if uncertain, treat as groomed and suggest improvements

                ## Issue Grooming Checklist (guidance only)
                ### Problem Definition
                - Title clearly summarizes the issue
                - Description explains what's broken and why it matters  
                - Context about where in the product the issue occurs

                ### Acceptance Criteria
                - Acceptance criteria defined as checklist
                - Each criterion testable/verifiable
                - Focus on user-facing behavior
                - Verification steps where appropriate

                ### Technical Information
                - Error messages with stack traces
                - Specific files/components identified
                - Configuration details if relevant
                - Environment information specified

                ### Reproducibility
                - Steps to reproduce numbered/complete
                - Expected vs actual behavior contrasted
                - Preconditions mentioned

                ### Dependencies & Context
                - Related issues/PRs referenced
                - Root causes/hypotheses provided
                - Workarounds documented
                - Impact assessment included

                ### Special Cases
                Feature requests: use case/story, success metrics, docs needs
                Technical debt: why it exists, refactoring ideas, risks
                Performance: metrics, expected vs actual, repro with test data

                ## Example: This SHOULD be groomed
                - Full error/stack trace included
                - Files involved identified  
                - Expected vs actual behavior stated
                - Proposed solution + acceptance criteria
                â†’ Set "is_groomed": true, provide analysis, minimal/no questions

                Now evaluate this GitHub issue:

                Title:
                ${title}

                Body:
                ${body}

                1. Can an engineer reasonably start work without synchronous clarification?
                2. Prefer "groomed" when problem + outcome + some detail exist

                Respond ONLY with a valid JSON object with this exact structure (no extra text before or after it):
                {
                  "is_groomed": boolean,
                  "analysis_markdown": string,
                  "questions_markdown": string
                }
              `.trim();
            }

            async function runGhModels(prompt) {
              const cmd = 'gh';
              const args = [
                'models',
                'run',
                'openai/gpt-4.1',   // or whatever model ID is enabled for your repo
                prompt,
              ];

              const { exitCode, stdout, stderr } = await exec.getExecOutput(cmd, args, {
                env: { ...process.env, GH_TOKEN: ghToken },
              });

              if (stderr) {
                core.debug(`gh stderr: ${stderr}`);
              }
              if (exitCode !== 0) {
                throw new Error(`gh models run failed with exit code ${exitCode}`);
              }
              return stdout.trim();
            }

            const since = new Date(Date.now() - 24 * 60 * 60 * 1000).toISOString();
            core.info(`Fetching issues since ${since}`);

            const issuesResp = await github.rest.issues.listForRepo({
              owner,
              repo,
              state: 'open',
              since,
              per_page: 100,
            });

            const issues = issuesResp.data.filter((issue) => !issue.pull_request);
            core.info(`Found ${issues.length} issues to groom`);

            if (issues.length === 0) {
              core.info('No issues to process, exiting.');
              return;
            }

            for (const issue of issues) {
              const number = issue.number;
              const title = issue.title || '';
              const body = issue.body || '';

              core.info(`Processing issue #${number}: ${title}`);

              const prompt = buildPrompt(title, body);
              const stdout = await runGhModels(prompt);
              core.debug(`Model raw output: ${stdout}`);

              let result;
              try {
                result = JSON.parse(stdout);
              } catch (err) {
                core.warning(
                  `Failed to parse model output for issue #${number}: ${err.message}`,
                );
                continue;
              }

              const isGroomed = !!result.is_groomed;
              const analysis = result.analysis_markdown || '';
              const questions = result.questions_markdown || '';

              let commentBody;
              if (isGroomed) {
                commentBody = `### ðŸ¤– Issue grooming analysis\n\n${analysis}\n\n_This analysis was generated automatically based on the repository's grooming checklist._`;
              } else {
                commentBody = `### ðŸ¤– Issue grooming questions\n\n${questions}\n\n_This comment was generated automatically to help gather the information needed to groom this issue._`;
              }

              await github.rest.issues.createComment({
                owner,
                repo,
                issue_number: number,
                body: commentBody,
              });

              try {
                if (isGroomed) {
                  await github.rest.issues.addLabels({
                    owner,
                    repo,
                    issue_number: number,
                    labels: ['groomed'],
                  });
                } else {
                  await github.rest.issues.addLabels({
                    owner,
                    repo,
                    issue_number: number,
                    labels: ['needs-info'],
                  });
                }
              } catch (err) {
                core.warning(
                  `Failed to add labels on issue #${number}: ${err.message}`,
                );
              }
            }
